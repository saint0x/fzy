enum Method {
    Get,
    Post,
    Put,
    Delete,
    Patch,
    Head,
    Options,
}

enum StatusClass {
    Informational,
    Success,
    Redirect,
    ClientError,
    ServerError,
    Unknown,
}

enum ConnectionMode {
    OneOff,
    Persistent,
}

struct Limits {
    max_header_bytes: i32,
    max_body_bytes: i32,
    request_timeout_ms: i32,
    idle_timeout_ms: i32,
}

struct ServePolicy {
    max_accept_retries: i32,
    read_stall_limit: i32,
    write_stall_limit: i32,
    keep_alive_max_requests: i32,
}

struct JsonPayload {
    map_handle: i32,
}

fn parse_method(name: str) -> Method {
    if name == "GET" then return Method::Get
    if name == "POST" then return Method::Post
    if name == "PUT" then return Method::Put
    if name == "DELETE" then return Method::Delete
    if name == "PATCH" then return Method::Patch
    if name == "HEAD" then return Method::Head
    return Method::Options
}

fn method_score_from_name(name: str) -> i32 {
    if name == "GET" then return 11
    if name == "POST" then return 13
    if name == "PUT" then return 17
    if name == "DELETE" then return 19
    if name == "PATCH" then return 23
    if name == "HEAD" then return 29
    return 31
}

fn method_score(method: Method) -> i32 {
    match method {
        Method::Get => return 11,
        Method::Post => return 13,
        Method::Put => return 17,
        Method::Delete => return 19,
        Method::Patch => return 23,
        Method::Head => return 29,
        Method::Options => return 31,
        _ => return 31,
    }
}

fn default_limits() -> Limits {
    return Limits {
        max_header_bytes: 16384,
        max_body_bytes: 1048576,
        request_timeout_ms: 2500,
        idle_timeout_ms: 10000,
    }
}

fn default_policy() -> ServePolicy {
    return ServePolicy {
        max_accept_retries: 32,
        read_stall_limit: 64,
        write_stall_limit: 64,
        keep_alive_max_requests: 16,
    }
}

fn sanitize_policy(policy: ServePolicy) -> ServePolicy {
    let mut retries = policy.max_accept_retries
    if retries < 1 { retries = 1 }
    if retries > 1000000 { retries = 1000000 }

    let mut read_stalls = policy.read_stall_limit
    if read_stalls < 1 { read_stalls = 1 }
    if read_stalls > 1000000 { read_stalls = 1000000 }

    let mut write_stalls = policy.write_stall_limit
    if write_stalls < 1 { write_stalls = 1 }
    if write_stalls > 1000000 { write_stalls = 1000000 }

    let mut keep_alive = policy.keep_alive_max_requests
    if keep_alive < 1 { keep_alive = 1 }
    if keep_alive > 1000000 { keep_alive = 1000000 }

    return ServePolicy {
        max_accept_retries: retries,
        read_stall_limit: read_stalls,
        write_stall_limit: write_stalls,
        keep_alive_max_requests: keep_alive,
    }
}

fn next_accept_backoff_ms(fail_streak: i32) -> i32 {
    if fail_streak < 1 then return 1
    if fail_streak < 8 then return 2
    if fail_streak < 64 then return 4
    if fail_streak < 512 then return 8
    return 16
}

fn should_keep_alive(connection_header: str, mode: ConnectionMode, handled: i32, policy: ServePolicy) -> i32 {
    if mode == ConnectionMode::OneOff then return 0
    if connection_header == "close" then return 0
    if handled >= policy.keep_alive_max_requests then return 0
    return 1
}

fn clamp_body_size(body_bytes: i32, limits: Limits) -> i32 {
    if body_bytes < 0 then return 0
    if body_bytes > limits.max_body_bytes {
        return limits.max_body_bytes
    }
    return body_bytes
}

fn clamp_body_size_max(body_bytes: i32, max_body_bytes: i32) -> i32 {
    let mut safe = body_bytes
    if safe < 0 {
        safe = 0
    }
    if safe > max_body_bytes {
        safe = max_body_bytes
    }
    return safe
}

fn status_class(status: i32) -> StatusClass {
    if status >= 100 && status < 200 { return StatusClass::Informational }
    if status >= 200 && status < 300 { return StatusClass::Success }
    if status >= 300 && status < 400 { return StatusClass::Redirect }
    if status >= 400 && status < 500 { return StatusClass::ClientError }
    if status >= 500 && status < 600 { return StatusClass::ServerError }
    return StatusClass::Unknown
}

fn status_class_score(class: StatusClass) -> i32 {
    match class {
        StatusClass::Informational => return 7,
        StatusClass::Success => return 11,
        StatusClass::Redirect => return 17,
        StatusClass::ClientError => return 23,
        StatusClass::ServerError => return 29,
        StatusClass::Unknown => return 31,
        _ => return 31,
    }
}

fn connection_mode_score(mode: ConnectionMode) -> i32 {
    match mode {
        ConnectionMode::OneOff => return 29,
        ConnectionMode::Persistent => return 41,
        _ => return 41,
    }
}

fn connection_session_score(mode: ConnectionMode, requests_per_connection: i32) -> i32 {
    let mut reqs = requests_per_connection
    if reqs < 1 {
        reqs = 1
    }
    match mode {
        ConnectionMode::OneOff => return (connection_mode_score(mode) + reqs) % 251,
        ConnectionMode::Persistent => return (connection_mode_score(mode) + (reqs * 7)) % 251,
        _ => return (connection_mode_score(mode) + (reqs * 7)) % 251,
    }
}

fn route_fingerprint(method: Method, path: str, query_len: i32, body_bytes: i32, limits: Limits) -> i32 {
    let safe_body = clamp_body_size(body_bytes, limits)
    let base = (method_score(method) * 131) + (str.len(path) * 17)
    let policy = (limits.request_timeout_ms % 97) + (limits.max_header_bytes % 89)
    return (base + (query_len * 7) + (safe_body % 251) + policy) % 251
}

fn route_fingerprint_fast(
    method_score: i32,
    path_len: i32,
    query_len: i32,
    body_bytes: i32,
    timeout_ms: i32,
    max_header_bytes: i32,
    max_body_bytes: i32
) -> i32 {
    let safe_body = clamp_body_size_max(body_bytes, max_body_bytes)
    let base = (method_score * 131) + (path_len * 17)
    let policy = (timeout_ms % 97) + (max_header_bytes % 89)
    return (base + (query_len * 7) + (safe_body % 251) + policy) % 251
}

fn json_payload_new() -> JsonPayload {
    return JsonPayload {
        map_handle: map.new(),
    }
}

fn json_payload_set_str(payload: JsonPayload, key: str, value: str) -> i32 {
    return map.set(payload.map_handle, key, json.str(value))
}

fn json_payload_set_raw(payload: JsonPayload, key: str, value_json: str) -> i32 {
    return map.set(payload.map_handle, key, value_json)
}

fn json_payload_encode(payload: JsonPayload) -> str {
    return json.object(payload.map_handle)
}

fn write_json_payload(conn: i32, status: i32, payload: JsonPayload) -> i32 {
    return http.write_json(conn, status, json_payload_encode(payload))
}

fn post_json_capture_payload(endpoint: str, payload: JsonPayload) -> str {
    return http.post_json_capture(endpoint, json_payload_encode(payload))
}

fn sample() -> i32 {
    let limits = default_limits()
    let policy = sanitize_policy(default_policy())
    let method_score = method_score_from_name("POST")
    let score = route_fingerprint_fast(
        method_score,
        str.len("/v1/users"),
        19,
        2048,
        limits.request_timeout_ms,
        limits.max_header_bytes,
        limits.max_body_bytes
    )
    let backoff = next_accept_backoff_ms(33)
    let keep_alive = should_keep_alive("keep-alive", ConnectionMode::Persistent, 3, policy)
    let oneoff = connection_session_score(ConnectionMode::OneOff, 1)
    let persistent = connection_session_score(ConnectionMode::Persistent, 8)
    let payload = json_payload_new()
    discard json_payload_set_str(payload, "component", "core.http")
    discard json_payload_set_raw(payload, "ok", "true")
    let _ = json_payload_encode(payload)
    return (score + status_class_score(status_class(201)) + oneoff + persistent + backoff + keep_alive) % 251
}
