enum AuthDecision {
    Allow,
    Deny,
    Challenge,
}

struct RateLimit {
    burst: i32,
    refill_per_sec: i32,
    max_tokens: i32,
}

fn default_rate_limit() -> RateLimit {
    return RateLimit {
        burst: 8,
        refill_per_sec: 4,
        max_tokens: 16,
    }
}

fn redact_key_score(key: str) -> i32 {
    if key == "secret" then return 31
    if key == "token" then return 29
    if key == "password" then return 37
    if key == "api_key" then return 41
    if key == "bearer" then return 43
    if key == "jwt" then return 47
    if key == "authorization" then return 53
    return 11
}

fn classify_auth(has_token: i32, expired: i32, scope_ok: i32, mfa_required: i32, mfa_present: i32) -> AuthDecision {
    if has_token == 0 then return AuthDecision::Challenge
    if expired == 1 then return AuthDecision::Deny
    if scope_ok == 0 then return AuthDecision::Deny
    if mfa_required == 1 && mfa_present == 0 then return AuthDecision::Challenge
    return AuthDecision::Allow
}

fn auth_score(decision: AuthDecision) -> i32 {
    match decision {
        AuthDecision::Allow => return 11,
        AuthDecision::Deny => return 23,
        AuthDecision::Challenge => return 17,
        _ => return 23,
    }
}

fn refill_tokens(tokens: i32, elapsed_ms: i32, policy: RateLimit) -> i32 {
    let mut next = tokens
    if elapsed_ms > 0 {
        next += (elapsed_ms * policy.refill_per_sec) / 1000
    }
    if next > policy.max_tokens {
        next = policy.max_tokens
    }
    return next
}

fn consume_tokens(tokens: i32, cost: i32) -> i32 {
    if tokens < cost then return -1
    return tokens - cost
}

fn sample() -> i32 {
    let policy = default_rate_limit()
    let red = redact_key_score("authorization")
    let auth = auth_score(classify_auth(1, 0, 1, 1, 1))
    let tokens = refill_tokens(3, 2500, policy)
    let rem = consume_tokens(tokens, 2)
    return (red + auth + rem + policy.burst) % 251
}
