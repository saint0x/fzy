const ITERATIONS: i32 = 8000000

fn enqueue_depth(depth: i32, capacity: i32, policy: i32) -> i32 {
    if depth < capacity {
        return depth + 1
    }

    if policy == 0 then return depth
    if policy == 1 then return capacity
    return depth
}

fn backpressure_score(depth: i32, capacity: i32) -> i32 {
    let watermark = (capacity * 3) / 4
    if depth >= capacity then return 31
    if depth >= watermark then return 17
    return 3
}

fn consume_depth(depth: i32, tick: i32) -> i32 {
    if tick % 3 == 0 {
        if depth <= 0 then return 0
        return depth - 1
    }
    return depth
}

fn workload() -> i32 {
    let capacity = 64
    let mut i: i32 = 0
    let mut depth: i32 = 0
    let mut policy: i32 = 0
    let mut acc: i32 = 0

    while i < ITERATIONS {
        depth = enqueue_depth(depth, capacity, policy)
        acc = (acc + backpressure_score(depth, capacity)) % 251
        depth = consume_depth(depth, i)
        acc = (acc + depth) % 251

        policy += 1
        if policy == 3 { policy = 0 }
        i += 1
    }

    return acc
}

fn main() -> i32 {
    return workload()
}
