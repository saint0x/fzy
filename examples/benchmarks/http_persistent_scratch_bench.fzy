const ITERATIONS: i32 = 8000000

fn parse_method_score(name: str) -> i32 {
    if name == "GET" then return 11
    if name == "POST" then return 13
    if name == "PUT" then return 17
    if name == "DELETE" then return 19
    if name == "PATCH" then return 23
    if name == "HEAD" then return 29
    return 31
}

fn status_score(status: i32) -> i32 {
    if status >= 100 && status < 200 { return 7 }
    if status >= 200 && status < 300 { return 11 }
    if status >= 300 && status < 400 { return 17 }
    if status >= 400 && status < 500 { return 23 }
    if status >= 500 && status < 600 { return 29 }
    return 31
}

fn route_score(method: str, path: str, query_len: i32, body_bytes: i32, timeout_ms: i32, max_body: i32) -> i32 {
    let mut safe_body = body_bytes
    if safe_body < 0 {
        safe_body = 0
    }
    if safe_body > max_body {
        safe_body = max_body
    }
    let base = (parse_method_score(method) * 131) + (str.len(path) * 17)
    return (base + (query_len * 7) + (safe_body % 251) + (timeout_ms % 97)) % 251
}

fn transport_score(connection_mode: i32, requests_on_conn: i32) -> i32 {
    let handshake = if connection_mode == 1 { 37 } else { 19 }
    let teardown = if connection_mode == 1 { 17 } else { 9 }
    return (handshake + teardown + (requests_on_conn % 13)) % 251
}

fn request_score(method: str, path: str, status: i32, query_len: i32, body_bytes: i32) -> i32 {
    let route = route_score(method, path, query_len, body_bytes, 2500, 1048576)
    let class = status_score(status)
    return (route + class) % 251
}

fn workload() -> i32 {
    let methods = ["GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"]
    let paths = ["/", "/v1/users", "/v1/orders", "/healthz"]
    let statuses = [200, 201, 204, 301, 404, 503]

    let mut i: i32 = 0
    let mut mi: i32 = 0
    let mut pi: i32 = 0
    let mut si: i32 = 0
    let mut acc: i32 = 0
    let mut left_on_conn: i32 = 0
    let mut conn_quota: i32 = 0

    while i < ITERATIONS {
        if left_on_conn == 0 {
            conn_quota = (i % 8) + 1
            left_on_conn = conn_quota
            acc = (acc + transport_score(2, conn_quota)) % 251
        }

        let method = methods[mi]
        let path = paths[pi]
        let status = statuses[si]
        let query_len = (i % 23) + 3
        let body_bytes = (i * 7) % 2000000

        let req = request_score(method, path, status, query_len, body_bytes)
        acc = (acc + req) % 251

        left_on_conn -= 1
        if left_on_conn == 0 {
            acc = (acc + 5) % 251
        }

        mi += 1
        if mi == 7 { mi = 0 }
        pi += 1
        if pi == 4 { pi = 0 }
        si += 1
        if si == 6 { si = 0 }
        i += 1
    }

    return acc
}

fn main() -> i32 {
    return workload()
}
