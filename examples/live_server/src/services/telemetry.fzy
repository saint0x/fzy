use core.fs;
use core.time;
use core.proc;

fn fields2(k1: str, v1: str, k2: str, v2: str) -> str {
    let m = map.new()
    discard map.set(m, k1, v1)
    discard map.set(m, k2, v2)
    return log.fields(m)
}

fn bootstrap_metrics() -> i32 {
    let h = fs.open()
    defer close(h)
    log.info("telemetry.bootstrap", fields2("component", "telemetry", "phase", "bootstrap"))
    fs.write()
    time.now()
    return 0
}

fn log_latency_bucket() -> i32 {
    let h = fs.open()
    defer close(h)
    log.info("telemetry.latency", fields2("component", "telemetry", "phase", "latency"))
    time.now()
    fs.write()
    return 0
}

fn log_perf_snapshot() -> i32 {
    let h = fs.open()
    defer close(h)
    proc.exec_timeout(100)
    log.info("telemetry.perf", fields2("component", "telemetry", "phase", "perf"))
    time.now()
    return 0
}

fn flush_runtime_stats() -> i32 {
    let h = fs.open()
    defer close(h)
    log.info("telemetry.flush", fields2("component", "telemetry", "phase", "flush"))
    fs.write()
    fs.flush()
    fs.fsync()
    return 0
}
