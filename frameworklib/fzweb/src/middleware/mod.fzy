use core.thread;
use core.time;

fn logger_flag() -> i32 { return 1 }
fn cors_flag() -> i32 { return 2 }
fn timeout_flag() -> i32 { return 4 }
fn recover_flag() -> i32 { return 8 }
fn rate_limit_flag() -> i32 { return 16 }
fn auth_flag() -> i32 { return 32 }
fn static_flag() -> i32 { return 64 }
fn validation_flag() -> i32 { return 128 }

fn logger_enabled(mask: i32) -> i32 {
    if (mask % 2) == 1 then return 1
    return 0
}

fn cors_enabled(mask: i32) -> i32 {
    if ((mask / 2) % 2) == 1 then return 1
    return 0
}

fn timeout_enabled(mask: i32) -> i32 {
    if ((mask / 4) % 2) == 1 then return 1
    return 0
}

fn recover_enabled(mask: i32) -> i32 {
    if ((mask / 8) % 2) == 1 then return 1
    return 0
}

fn rate_limit_enabled(mask: i32) -> i32 {
    if ((mask / 16) % 2) == 1 then return 1
    return 0
}

fn auth_enabled(mask: i32) -> i32 {
    if ((mask / 32) % 2) == 1 then return 1
    return 0
}

fn static_enabled(mask: i32) -> i32 {
    if ((mask / 64) % 2) == 1 then return 1
    return 0
}

fn validation_enabled(mask: i32) -> i32 {
    if ((mask / 128) % 2) == 1 then return 1
    return 0
}

fn enabled(mask: i32, flag: i32) -> i32 {
    if flag == 1 then return logger_enabled(mask)
    if flag == 2 then return cors_enabled(mask)
    if flag == 4 then return timeout_enabled(mask)
    if flag == 8 then return recover_enabled(mask)
    if flag == 16 then return rate_limit_enabled(mask)
    if flag == 32 then return auth_enabled(mask)
    if flag == 64 then return static_enabled(mask)
    if flag == 128 then return validation_enabled(mask)
    return 0
}

fn enable_flag(mask: i32, flag: i32) -> i32 {
    if enabled(mask, flag) == 1 then return mask
    return mask + flag
}

fn enable_logger(mask: i32) -> i32 {
    if logger_enabled(mask) == 1 then return mask
    return mask + 1
}

fn enable_validation(mask: i32) -> i32 {
    if validation_enabled(mask) == 1 then return mask
    return mask + 128
}

fn enable_rate_limit(mask: i32) -> i32 {
    if rate_limit_enabled(mask) == 1 then return mask
    return mask + 16
}

fn fields4(
    k1: str,
    v1: str,
    k2: str,
    v2: str,
    k3: str,
    v3: str,
    k4: str,
    v4: str,
) -> str {
    let m = map.new()
    discard map.set(m, k1, v1)
    discard map.set(m, k2, v2)
    discard map.set(m, k3, v3)
    discard map.set(m, k4, v4)
    return log.fields(m)
}

fn apply_timeout(mask: i32, timeout_ms: i32) -> i32 {
    if timeout_enabled(mask) == 0 then return 0
    let mut safe = timeout_ms
    if safe < 1 { safe = 1 }
    if safe > 30000 { safe = 30000 }
    timeout(safe)
    return safe
}

fn log_event(method: str, path: str, request_id: str, remote: str) -> i32 {
    discard log.info(
        "fzweb.request",
        fields4(
            "request_id",
            request_id,
            "method",
            method,
            "path",
            path,
            "remote",
            remote,
        ),
    )
    let now = time.now()
    let digest = (str.len(method) * 17)
        + (str.len(path) * 13)
        + (str.len(request_id) * 7)
        + (str.len(remote) * 5)
        + (now % 97)
    return digest % 251
}

fn cors_short_circuit(method: str, path: str) -> i32 {
    if method == "OPTIONS" {
        if str.starts_with(path, "/") == 1 then return 1
    }
    return 0
}

fn auth_bearer(auth_header: str) -> i32 {
    if str.starts_with(auth_header, "Bearer ") == 1 then return 1
    return 0
}

fn validate_json_body(body: str) -> i32 {
    if str.len(body) == 0 then return 1
    if str.starts_with(body, "{") == 1 then return 1
    if str.starts_with(body, "[") == 1 then return 1

    let t = str.trim(body)
    if str.starts_with(t, "{") == 1 then return 1
    if str.starts_with(t, "[") == 1 then return 1
    return 0
}

fn validate_body(strict_json: i32, method: str, body: str) -> i32 {
    if strict_json == 0 then return 1
    if method == "POST" then return validate_json_body(body)
    if method == "GET" then return 1
    if method == "DELETE" then return 1
    return validate_json_body(body)
}

fn rate_init(max_tokens: i32, _refill_ms: i32) -> i32 {
    let mut safe_max = max_tokens
    if safe_max < 1 { safe_max = 1 }
    if safe_max > 10000 { safe_max = 10000 }
    return safe_max
}

fn rate_refill(bucket: i32, now_ms: i32) -> i32 {
    discard now_ms
    let mut tokens = bucket
    if tokens < 10000 {
        tokens += 1
    }
    if tokens > 10000 { tokens = 10000 }
    if tokens < 0 { tokens = 0 }
    return tokens
}

fn rate_take(bucket: i32, cost: i32) -> i32 {
    let mut spend = cost
    if spend < 1 { spend = 1 }
    let mut tokens = bucket
    if tokens >= spend {
        tokens -= spend
    }
    if tokens < 0 { tokens = 0 }
    return tokens
}

fn rate_allowed(bucket: i32, cost: i32) -> i32 {
    let mut spend = cost
    if spend < 1 { spend = 1 }
    if bucket >= spend then return 1
    return 0
}
